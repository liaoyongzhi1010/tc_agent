# OP-TEE 完整开发环境 Docker 镜像
# 功能：编译 TA/CA + QEMU 运行测试
# 基于 Ubuntu 22.04 + OP-TEE 4.0 + QEMU

FROM ubuntu:22.04

LABEL maintainer="TC Agent"
LABEL description="OP-TEE Development Environment (Build + QEMU Runtime)"
LABEL optee_version="4.0"

# 避免交互式提示
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Shanghai

# 启用多架构包（安装 arm64 依赖用于交叉编译）
RUN dpkg --add-architecture arm64 && \
    printf "deb [arch=amd64] http://archive.ubuntu.com/ubuntu jammy main restricted universe multiverse\n\
deb [arch=amd64] http://archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse\n\
deb [arch=amd64] http://archive.ubuntu.com/ubuntu jammy-backports main restricted universe multiverse\n\
deb [arch=amd64] http://security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse\n" \
    > /etc/apt/sources.list && \
    printf "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports jammy main restricted universe multiverse\n\
deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted universe multiverse\n\
deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted universe multiverse\n\
deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports jammy-backports main restricted universe multiverse\n" \
    > /etc/apt/sources.list.d/arm64.list

# ========================================
# 1. 安装基础依赖
# ========================================
RUN apt-get update && apt-get install -y \
    android-tools-adb \
    android-tools-fastboot \
    autoconf \
    automake \
    bc \
    bison \
    build-essential \
    ccache \
    cpio \
    cscope \
    curl \
    device-tree-compiler \
    expect \
    flex \
    ftp-upload \
    gdisk \
    git \
    kmod \
    libattr1-dev \
    libcap-dev \
    libfdt-dev \
    libftdi-dev \
    libglib2.0-dev \
    libgmp-dev \
    libhidapi-dev \
    libmpc-dev \
    libncurses5-dev \
    libpixman-1-dev \
    libslirp-dev \
    libssl-dev \
    libssl-dev:arm64 \
    libtool \
    make \
    mtools \
    netcat \
    ninja-build \
    python3 \
    python3-pip \
    python3-cryptography \
    python3-pyelftools \
    python3-serial \
    rsync \
    unzip \
    uuid-dev \
    uuid-dev:arm64 \
    libuuid1:arm64 \
    wget \
    xdg-utils \
    xterm \
    xz-utils \
    zlib1g-dev \
    dosfstools \
    file \
    pkg-config \
    xxd \
    && rm -rf /var/lib/apt/lists/*

# optee_client/libteeacl 依赖 <uuid.h>，在 Ubuntu 中为 uuid/uuid.h
RUN if [ -f /usr/include/uuid/uuid.h ]; then ln -sf /usr/include/uuid/uuid.h /usr/include/uuid.h; fi

# 交叉编译 xtest 需要 opensslconf.h（多架构路径），提供一个稳定的 include 入口
RUN if [ ! -f /usr/include/openssl/opensslconf.h ]; then \
        if [ -f /usr/include/aarch64-linux-gnu/openssl/opensslconf.h ]; then \
            ln -sf /usr/include/aarch64-linux-gnu/openssl/opensslconf.h /usr/include/openssl/opensslconf.h; \
        elif [ -f /usr/include/x86_64-linux-gnu/openssl/opensslconf.h ]; then \
            ln -sf /usr/include/x86_64-linux-gnu/openssl/opensslconf.h /usr/include/openssl/opensslconf.h; \
        fi; \
    fi
# optee_client 期望 aarch64-linux-gnu-pkg-config（兼容 uuid.pc 缺失场景）
RUN cat > /usr/bin/aarch64-linux-gnu-pkg-config << 'EOF'
#!/bin/sh
uuid=0
for a in "$@"; do
  [ "$a" = "uuid" ] && uuid=1
done
if [ "$uuid" -eq 1 ]; then
  case " $* " in
    *" --modversion "*) echo "2.37.2"; exit 0;;
    *" --cflags "*) echo "-I/usr/include"; exit 0;;
    *" --libs "*) echo "-L/usr/lib/aarch64-linux-gnu -luuid"; exit 0;;
    *" --exists "*) exit 0;;
    *" --atleast-version="*) exit 0;;
    *" --atleast-version "*) exit 0;;
  esac
fi
PKG_CONFIG_LIBDIR=/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig exec /usr/bin/pkg-config "$@"
EOF
RUN chmod +x /usr/bin/aarch64-linux-gnu-pkg-config
# 确保 aarch64 的 libuuid 可被 -luuid 找到，并提供 uuid.pc
RUN if [ -f /usr/lib/aarch64-linux-gnu/libuuid.so.1 ] && [ ! -f /usr/lib/aarch64-linux-gnu/libuuid.so ]; then \
        ln -sf /usr/lib/aarch64-linux-gnu/libuuid.so.1 /usr/lib/aarch64-linux-gnu/libuuid.so; \
    fi && \
    if [ ! -f /usr/lib/aarch64-linux-gnu/pkgconfig/uuid.pc ]; then \
        mkdir -p /usr/lib/aarch64-linux-gnu/pkgconfig && \
        printf 'prefix=/usr\nexec_prefix=${prefix}\nlibdir=/usr/lib/aarch64-linux-gnu\nincludedir=/usr/include\n\nName: uuid\nDescription: uuid library\nVersion: 2.37.2\nLibs: -L${libdir} -luuid\nCflags: -I${includedir}\n' \
        > /usr/lib/aarch64-linux-gnu/pkgconfig/uuid.pc; \
    fi

# 安装 ARM 交叉编译工具链
RUN apt-get update && apt-get install -y \
    gcc-aarch64-linux-gnu \
    g++-aarch64-linux-gnu \
    binutils-aarch64-linux-gnu \
    gcc-arm-linux-gnueabihf \
    g++-arm-linux-gnueabihf \
    && rm -rf /var/lib/apt/lists/*

# 创建工作目录
WORKDIR /optee

# ========================================
# 2. 下载并编译 OP-TEE 组件
# ========================================
RUN git clone --depth 1 --branch 4.0.0 https://github.com/OP-TEE/optee_os.git && \
    git clone --depth 1 --branch 4.0.0 https://github.com/OP-TEE/optee_client.git && \
    git clone --depth 1 --branch 4.0.0 https://github.com/OP-TEE/optee_test.git

# 编译 OP-TEE OS (QEMU ARMv8)
RUN cd /optee/optee_os && \
    make PLATFORM=vexpress-qemu_armv8a CFG_ARM64_core=y \
    CROSS_COMPILE=aarch64-linux-gnu- \
    CROSS_COMPILE_core=aarch64-linux-gnu- \
    CROSS_COMPILE_ta_arm64=aarch64-linux-gnu- \
    ta-targets=ta_arm64 \
    -j$(nproc)

# 编译 OP-TEE Client
RUN cd /optee/optee_client && \
    PKG_CONFIG=aarch64-linux-gnu-pkg-config \
    make CROSS_COMPILE=aarch64-linux-gnu- \
    CFG_TEE_SUPP_PLUGINS=y \
    CFG_TEE_PLUGIN_LOAD_PATH=/usr/lib/tee-supplicant/plugins \
    -j$(nproc)

# 设置 TA 开发环境变量
ENV TA_DEV_KIT_DIR=/optee/optee_os/out/arm-plat-vexpress/export-ta_arm64
ENV TEEC_EXPORT=/optee/optee_client/out/export/usr
ENV CROSS_COMPILE=aarch64-linux-gnu-

# ========================================
# 3. 编译 QEMU (支持 ARM64 + TrustZone)
# ========================================
RUN git clone --depth 1 --branch v8.1.0 https://github.com/qemu/qemu.git && \
    cd qemu && \
    ./configure \
        --target-list=aarch64-softmmu \
        --enable-slirp \
        --disable-werror && \
    make -j$(nproc) && \
    make install && \
    cd .. && rm -rf qemu

# 3.5 生成 QEMU virt DTB 并写入 bootargs（供 TF-A NT_FW_CONFIG 使用）
RUN qemu-system-aarch64 -machine virt,secure=on,gic-version=2,virtualization=false,dumpdtb=/optee/virt.dtb -cpu cortex-a57 -smp 1 -m 2048 -display none -nographic && \
    fdtput -t s -p /optee/virt.dtb /chosen bootargs "console=ttyAMA0,115200 earlycon=pl011,0x09000000 rdinit=/sbin/init loglevel=8"

# ========================================
# 4. 编译 Linux 内核 (带 OP-TEE 支持)
# ========================================
RUN git clone --depth 1 --branch v6.1 https://github.com/torvalds/linux.git linux && \
    cd linux && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig && \
    # 启用必要的内核选项
    ./scripts/config --enable TEE && \
    ./scripts/config --enable OPTEE && \
    ./scripts/config --enable VIRTIO_MMIO && \
    ./scripts/config --enable VIRTIO_CONSOLE && \
    ./scripts/config --enable HW_RANDOM && \
    ./scripts/config --enable HW_RANDOM_VIRTIO && \
    ./scripts/config --enable DEVTMPFS && \
    ./scripts/config --enable DEVTMPFS_MOUNT && \
    ./scripts/config --enable TMPFS && \
    ./scripts/config --enable UNIX && \
    ./scripts/config --enable INET && \
    ./scripts/config --enable SERIAL_AMBA_PL011 && \
    ./scripts/config --enable SERIAL_AMBA_PL011_CONSOLE && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- olddefconfig && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) Image && \
    cp arch/arm64/boot/Image /optee/Image && \
    cd .. && rm -rf linux

# ========================================
# 4.5 编译 ARM Trusted Firmware (TF-A)
# ========================================
RUN git clone --depth 1 --branch v2.10.0 https://github.com/ARM-software/arm-trusted-firmware.git tf-a

# 放大 QEMU FIP 可用空间（内核作为 BL33 时需要更大 FIP）
RUN sed -i 's/^#define PLAT_QEMU_FIP_MAX_SIZE.*/#define PLAT_QEMU_FIP_MAX_SIZE 0x03FC0000/' /optee/tf-a/plat/qemu/qemu/include/platform_def.h

# 编译 TF-A + OP-TEE for QEMU virt 平台
RUN cd /optee/tf-a && \
    make PLAT=qemu \
    ARM_ARCH_MAJOR=8 \
    BL32=/optee/optee_os/out/arm-plat-vexpress/core/tee-header_v2.bin \
    BL32_EXTRA1=/optee/optee_os/out/arm-plat-vexpress/core/tee-pager_v2.bin \
    BL32_EXTRA2=/optee/optee_os/out/arm-plat-vexpress/core/tee-pageable_v2.bin \
    BL33=/optee/Image \
    ARM_LINUX_KERNEL_AS_BL33=1 \
    SPD=opteed \
    CROSS_COMPILE=aarch64-linux-gnu- \
    DEBUG=1 \
    LOG_LEVEL=50 \
    -j$(nproc) all fip

# 复制 ATF 输出文件并创建 flash.bin
RUN mkdir -p /optee/atf && \
    cp /optee/tf-a/build/qemu/debug/bl1.bin /optee/atf/ && \
    cp /optee/tf-a/build/qemu/debug/fip.bin /optee/atf/ && \
    dd if=/dev/zero of=/optee/atf/flash.bin bs=1M count=64 && \
    dd if=/optee/atf/bl1.bin of=/optee/atf/flash.bin conv=notrunc && \
    dd if=/optee/atf/fip.bin of=/optee/atf/flash.bin seek=64 bs=4096 conv=notrunc

# ========================================
# 5. 编译 BusyBox (创建最小 rootfs)
# ========================================
RUN git clone --depth 1 --branch 1_36_1 https://github.com/mirror/busybox.git && \
    cd busybox && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig && \
    sed -i 's/# CONFIG_STATIC is not set/CONFIG_STATIC=y/' .config && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc) && \
    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- CONFIG_PREFIX=/optee/rootfs install && \
    cd .. && rm -rf busybox

# ========================================
# 6. 创建 rootfs 结构
# ========================================
RUN mkdir -p /optee/rootfs/dev \
    /optee/rootfs/proc \
    /optee/rootfs/sys \
    /optee/rootfs/tmp \
    /optee/rootfs/data/tee \
    /optee/rootfs/etc/init.d \
    /optee/rootfs/root \
    /optee/rootfs/var/run \
    /optee/rootfs/var/lib/tee \
    /optee/rootfs/lib/optee_armtz \
    /optee/rootfs/usr/lib \
    /optee/rootfs/usr/lib/tee-supplicant/plugins \
    /optee/rootfs/usr/bin \
    /optee/rootfs/usr/sbin

# 复制 OP-TEE 客户端库和工具
RUN cp -a /optee/optee_client/out/export/usr/lib/*.so* /optee/rootfs/usr/lib/ && \
    cp /optee/optee_client/out/tee-supplicant/tee-supplicant /optee/rootfs/usr/sbin/ && \
    cp /optee/optee_os/out/arm-plat-vexpress/ta/*/*.ta /optee/rootfs/lib/optee_armtz/ 2>/dev/null || true && \
    cp /optee/optee_test/out/supp_plugin/*.plugin /optee/rootfs/usr/lib/tee-supplicant/plugins/ 2>/dev/null || true && \
    mkdir -p /optee/rootfs/lib/aarch64-linux-gnu && \
    cp -a /lib/aarch64-linux-gnu/libc.so.6 /lib/aarch64-linux-gnu/libm.so.6 /optee/rootfs/lib/aarch64-linux-gnu/ && \
    cp -a /lib/aarch64-linux-gnu/ld-linux-aarch64.so.1 /optee/rootfs/lib/aarch64-linux-gnu/ && \
    ln -sf aarch64-linux-gnu/ld-linux-aarch64.so.1 /optee/rootfs/lib/ld-linux-aarch64.so.1 && \
    cp -a /usr/lib/aarch64-linux-gnu/libcrypto.so.3 /optee/rootfs/usr/lib/ && \
    cd /optee/rootfs/lib && \
    ln -sf ../usr/lib/libteec.so.1.0.0 libteec.so.1.0.0 && \
    ln -sf libteec.so.1.0.0 libteec.so.1 && \
    ln -sf libteec.so.1 libteec.so

# 编译 xtest (OP-TEE 测试套件)
RUN cd /optee/optee_test && \
    make CROSS_COMPILE=aarch64-linux-gnu- \
    TA_DEV_KIT_DIR=/optee/optee_os/out/arm-plat-vexpress/export-ta_arm64 \
    OPTEE_CLIENT_EXPORT=/optee/optee_client/out/export/usr \
    CFG_ARM64=y \
    -j$(nproc) || true && \
    # 复制 xtest 到 rootfs
    cp /optee/optee_test/out/xtest/xtest /optee/rootfs/usr/bin/ 2>/dev/null || true && \
    # 复制测试 TA
    cp /optee/optee_test/out/ta/*/*.ta /optee/rootfs/lib/optee_armtz/ 2>/dev/null || true && \
    # 复制 supplicant plugin（需在 optee_test 编译后）
    cp /optee/optee_test/out/supp_plugin/*.plugin /optee/rootfs/usr/lib/tee-supplicant/plugins/ 2>/dev/null || true

# 创建设备节点
RUN cd /optee/rootfs && \
    mknod -m 666 dev/null c 1 3 && \
    mknod -m 666 dev/zero c 1 5 && \
    mknod -m 666 dev/tty c 5 0 && \
    mknod -m 622 dev/console c 5 1 && \
    mknod -m 666 dev/ptmx c 5 2 && \
    mknod -m 666 dev/random c 1 8 && \
    mknod -m 666 dev/urandom c 1 9 && \
    mkdir -p dev/pts

# 创建启动脚本
RUN echo '#!/bin/sh\n\
mount -t proc proc /proc\n\
mount -t sysfs sysfs /sys\n\
mount -t devtmpfs devtmpfs /dev\n\
mount -t devpts devpts /dev/pts 2>/dev/null || true\n\
mount -t tmpfs tmpfs /tmp\n\
/sbin/ifconfig lo up 2>/dev/null || true\n\
\n\
echo ""\n\
echo "========================================"\n\
echo "  OP-TEE QEMU Environment Starting..."\n\
echo "========================================"\n\
\n\
# 启动 tee-supplicant\n\
echo "Starting tee-supplicant..."\n\
/usr/sbin/tee-supplicant -p /usr/lib/tee-supplicant/plugins &\n\
sleep 1\n\
\n\
echo ""\n\
echo "Available TAs in /lib/optee_armtz/:"\n\
ls /lib/optee_armtz/*.ta 2>/dev/null || echo "  (none)"\n\
echo ""\n\
echo "========================================"\n\
echo "  OP-TEE Ready! Run your CA to test."\n\
echo "========================================"\n\
echo ""\n\
\n\
exec /bin/sh\n\
' > /optee/rootfs/etc/init.d/rcS && chmod +x /optee/rootfs/etc/init.d/rcS

# 创建 inittab
RUN echo '::sysinit:/etc/init.d/rcS\n\
::respawn:-/bin/sh\n\
::restart:/sbin/init\n\
' > /optee/rootfs/etc/inittab

# 创建基础 initramfs (不含用户 TA)
RUN cd /optee/rootfs && \
    find . | cpio -H newc -o 2>/dev/null | gzip > /optee/rootfs.cpio.gz

# ========================================
# 7. 创建工具脚本
# ========================================

# TA 编译脚本
RUN echo '#!/bin/bash\n\
set -e\n\
if [ -z "$1" ]; then\n\
    echo "Usage: build_ta.sh <ta_directory>"\n\
    exit 1\n\
fi\n\
TA_DIR=$1\n\
cd $TA_DIR\n\
make CROSS_COMPILE=aarch64-linux-gnu- \\\n\
     TA_DEV_KIT_DIR=/optee/optee_os/out/arm-plat-vexpress/export-ta_arm64 \\\n\
     -j$(nproc)\n\
echo ""\n\
echo "TA build completed!"\n\
ls -la *.ta 2>/dev/null || echo "No .ta file generated"\n\
' > /usr/local/bin/build_ta.sh && chmod +x /usr/local/bin/build_ta.sh

# CA 编译脚本
RUN echo '#!/bin/bash\n\
set -e\n\
if [ -z "$1" ]; then\n\
    echo "Usage: build_ca.sh <ca_directory>"\n\
    exit 1\n\
fi\n\
CA_DIR=$1\n\
cd $CA_DIR\n\
make CROSS_COMPILE=aarch64-linux-gnu- \\\n\
     TEEC_EXPORT=/optee/optee_client/out/export/usr \\\n\
     -j$(nproc)\n\
echo "CA build completed!"\n\
' > /usr/local/bin/build_ca.sh && chmod +x /usr/local/bin/build_ca.sh

# QEMU 运行脚本 (使用 ATF + OP-TEE)
RUN echo '#!/bin/bash\n\
\n\
TA_DIR=${1:-}\n\
CA_FILE=${2:-}\n\
\n\
# 准备 rootfs\n\
WORK_DIR=$(mktemp -d)\n\
cd $WORK_DIR\n\
zcat /optee/rootfs.cpio.gz | cpio -idm 2>/dev/null\n\
\n\
# 复制用户 TA\n\
if [ -n "$TA_DIR" ] && [ -d "$TA_DIR" ]; then\n\
    echo "Loading TAs from: $TA_DIR"\n\
    cp $TA_DIR/*.ta lib/optee_armtz/ 2>/dev/null || true\n\
fi\n\
\n\
# 复制用户 CA\n\
if [ -n "$CA_FILE" ] && [ -f "$CA_FILE" ]; then\n\
    echo "Loading CA: $CA_FILE"\n\
    cp $CA_FILE usr/bin/\n\
    chmod +x usr/bin/$(basename $CA_FILE)\n\
fi\n\
\n\
# 重新打包 rootfs\n\
find . | cpio -H newc -o 2>/dev/null | gzip > /tmp/rootfs_custom.cpio.gz\n\
\n\
INITRD_ADDR=0x48000000\n\
INITRD_SIZE=$(stat -c %s /tmp/rootfs_custom.cpio.gz)\n\
INITRD_END=$(printf "0x%x" $((INITRD_ADDR + INITRD_SIZE)))\n\
cp /optee/virt.dtb /tmp/virt.dtb\n\
fdtput -p -t x /tmp/virt.dtb /chosen linux,initrd-start 0x0 $INITRD_ADDR\n\
fdtput -p -t x /tmp/virt.dtb /chosen linux,initrd-end 0x0 $INITRD_END\n\
fdtput -p -t s /tmp/virt.dtb /pl061@9030000 status "disabled"\n\
fdtput -p -t s /tmp/virt.dtb /gpio-keys status "disabled"\n\
\n\
echo ""\n\
echo "Starting QEMU with OP-TEE (ATF boot)..."\n\
echo "(Press Ctrl+A then X to exit)"\n\
echo ""\n\
\n\
qemu-system-aarch64 \\\n\
    -nographic \\\n\
    -serial mon:stdio \\\n\
    -machine virt,secure=on,gic-version=2,virtualization=false \\\n\
    -cpu cortex-a57 \\\n\
    -smp 1 \\\n\
    -m 2048 \\\n\
    -bios /optee/atf/flash.bin \\\n\
    -dtb /tmp/virt.dtb \\\n\
    -device loader,file=/tmp/rootfs_custom.cpio.gz,addr=$INITRD_ADDR \\\n\
    -no-reboot\n\
\n\
rm -rf $WORK_DIR /tmp/rootfs_custom.cpio.gz\n\
' > /usr/local/bin/run_qemu.sh && chmod +x /usr/local/bin/run_qemu.sh

# 快速测试脚本 (非交互式)
RUN echo '#!/bin/bash\n\
\n\
TA_DIR=$1\n\
ARG2=$2\n\
ARG3=$3\n\
ARG4=$4\n\
CA_FILE=""\n\
TEST_CMD=""\n\
TIMEOUT=10\n\
\n\
if [ -z "$TA_DIR" ]; then\n\
    echo "Usage: test_ta.sh <ta_directory> [ca_file|test_command] [test_command] [timeout]"\n\
    exit 1\n\
fi\n\
\n\
if [ -n "$ARG2" ] && [ -f "$ARG2" ]; then\n\
    CA_FILE="$ARG2"\n\
    TEST_CMD=${ARG3:-"/usr/bin/$(basename "$CA_FILE")"}\n\
    TIMEOUT=${ARG4:-10}\n\
else\n\
    TEST_CMD=${ARG2:-"echo TA loaded successfully"}\n\
    TIMEOUT=${ARG3:-10}\n\
fi\n\
\n\
# 准备 rootfs\n\
WORK_DIR=$(mktemp -d)\n\
cd $WORK_DIR\n\
zcat /optee/rootfs.cpio.gz | cpio -idm 2>/dev/null\n\
\n\
# 复制用户 TA\n\
if [ -d "$TA_DIR" ]; then\n\
    cp $TA_DIR/*.ta lib/optee_armtz/ 2>/dev/null || true\n\
    echo "Loaded TAs:"\n\
    ls lib/optee_armtz/*.ta 2>/dev/null\n\
fi\n\
\n\
# 复制用户 CA\n\
if [ -n "$CA_FILE" ] && [ -f "$CA_FILE" ]; then\n\
    echo "Loading CA: $CA_FILE"\n\
    cp $CA_FILE usr/bin/\n\
    chmod +x usr/bin/$(basename $CA_FILE)\n\
fi\n\
\n\
# 修改启动脚本，运行测试后自动退出\n\
cat > etc/init.d/rcS << EOF\n\
#!/bin/sh\n\
mount -t proc proc /proc\n\
mount -t sysfs sysfs /sys\n\
mount -t devtmpfs devtmpfs /dev\n\
/sbin/ifconfig lo up 2>/dev/null || true\n\
/usr/sbin/tee-supplicant -p /usr/lib/tee-supplicant/plugins &\n\
sleep 1\n\
echo ""\n\
echo "========================================"\n\
echo "  Running TA Test..."\n\
echo "========================================"\n\
echo ""\n\
$TEST_CMD\n\
RET=$?\n\
echo "CA_EXIT_CODE=$RET"\n\
echo "=== TEST_COMPLETE ==="\n\
echo ""\n\
echo "========================================"\n\
echo "  Test Complete!"\n\
echo "========================================"\n\
poweroff -f\n\
EOF\n\
chmod +x etc/init.d/rcS\n\
\n\
find . | cpio -H newc -o 2>/dev/null | gzip > /tmp/rootfs_test.cpio.gz\n\
\n\
INITRD_ADDR=0x48000000\n\
INITRD_SIZE=$(stat -c %s /tmp/rootfs_test.cpio.gz)\n\
INITRD_END=$(printf "0x%x" $((INITRD_ADDR + INITRD_SIZE)))\n\
cp /optee/virt.dtb /tmp/virt.dtb\n\
fdtput -p -t x /tmp/virt.dtb /chosen linux,initrd-start 0x0 $INITRD_ADDR\n\
fdtput -p -t x /tmp/virt.dtb /chosen linux,initrd-end 0x0 $INITRD_END\n\
fdtput -p -t s /tmp/virt.dtb /pl061@9030000 status "disabled"\n\
fdtput -p -t s /tmp/virt.dtb /gpio-keys status "disabled"\n\
\n\
echo ""\n\
echo "Running QEMU test (timeout: ${TIMEOUT}s)..."\n\
echo ""\n\
\n\
timeout $TIMEOUT qemu-system-aarch64 \\\n\
    -nographic \\\n\
    -serial mon:stdio \\\n\
    -machine virt,secure=on,gic-version=2,virtualization=false \\\n\
    -cpu cortex-a57 \\\n\
    -smp 1 \\\n\
    -m 2048 \\\n\
    -bios /optee/atf/flash.bin \\\n\
    -dtb /tmp/virt.dtb \\\n\
    -device loader,file=/tmp/rootfs_test.cpio.gz,addr=$INITRD_ADDR \\\n\
    -no-reboot 2>&1 || true\n\
\n\
rm -rf $WORK_DIR /tmp/rootfs_test.cpio.gz\n\
' > /usr/local/bin/test_ta.sh && chmod +x /usr/local/bin/test_ta.sh

# 简化模式 QEMU 运行脚本 (无 TrustZone，用于 Mac 开发环境)
RUN echo '#!/bin/bash\n\
\n\
TA_DIR=${1:-}\n\
CA_FILE=${2:-}\n\
\n\
# 准备 rootfs\n\
WORK_DIR=$(mktemp -d)\n\
cd $WORK_DIR\n\
zcat /optee/rootfs.cpio.gz | cpio -idm 2>/dev/null\n\
\n\
# 复制用户 TA\n\
if [ -n "$TA_DIR" ] && [ -d "$TA_DIR" ]; then\n\
    echo "Loading TAs from: $TA_DIR"\n\
    cp $TA_DIR/*.ta lib/optee_armtz/ 2>/dev/null || true\n\
fi\n\
\n\
# 复制用户 CA\n\
if [ -n "$CA_FILE" ] && [ -f "$CA_FILE" ]; then\n\
    echo "Loading CA: $CA_FILE"\n\
    cp $CA_FILE usr/bin/\n\
    chmod +x usr/bin/$(basename $CA_FILE)\n\
fi\n\
\n\
# 重新打包 rootfs\n\
find . | cpio -H newc -o 2>/dev/null | gzip > /tmp/rootfs_custom.cpio.gz\n\
\n\
echo ""\n\
echo "Starting QEMU (Simple Mode - No TrustZone)..."\n\
echo "(Press Ctrl+A then X to exit)"\n\
echo ""\n\
\n\
qemu-system-aarch64 \\\n\
    -nographic \\\n\
    -machine virt \\\n\
    -cpu cortex-a57 \\\n\
    -smp 2 \\\n\
    -m 1024 \\\n\
    -kernel /optee/Image \\\n\
    -initrd /tmp/rootfs_custom.cpio.gz \\\n\
    -append "console=ttyAMA0 rdinit=/sbin/init" \\\n\
    -no-reboot\n\
\n\
rm -rf $WORK_DIR /tmp/rootfs_custom.cpio.gz\n\
' > /usr/local/bin/run_qemu_simple.sh && chmod +x /usr/local/bin/run_qemu_simple.sh

# 简化模式测试脚本 (非交互式，无 TrustZone)
RUN echo '#!/bin/bash\n\
\n\
TA_DIR=$1\n\
ARG2=$2\n\
ARG3=$3\n\
ARG4=$4\n\
CA_FILE=""\n\
TEST_CMD=""\n\
TIMEOUT=30\n\
\n\
if [ -z "$TA_DIR" ]; then\n\
    echo "Usage: test_ta_simple.sh <ta_directory> [ca_file|test_command] [test_command] [timeout]"\n\
    exit 1\n\
fi\n\
\n\
if [ -n "$ARG2" ] && [ -f "$ARG2" ]; then\n\
    CA_FILE="$ARG2"\n\
    TEST_CMD=${ARG3:-"echo TA loaded successfully"}\n\
    TIMEOUT=${ARG4:-30}\n\
else\n\
    TEST_CMD=${ARG2:-"echo TA loaded successfully"}\n\
    TIMEOUT=${ARG3:-30}\n\
fi\n\
\n\
# 准备 rootfs\n\
WORK_DIR=$(mktemp -d)\n\
cd $WORK_DIR\n\
zcat /optee/rootfs.cpio.gz | cpio -idm 2>/dev/null\n\
\n\
# 复制用户 TA\n\
if [ -d "$TA_DIR" ]; then\n\
    cp $TA_DIR/*.ta lib/optee_armtz/ 2>/dev/null || true\n\
    echo "Loaded TAs:"\n\
    ls lib/optee_armtz/*.ta 2>/dev/null\n\
fi\n\
\n\
# 复制用户 CA\n\
if [ -n "$CA_FILE" ] && [ -f "$CA_FILE" ]; then\n\
    echo "Loading CA: $CA_FILE"\n\
    cp $CA_FILE usr/bin/\n\
    chmod +x usr/bin/$(basename $CA_FILE)\n\
fi\n\
\n\
# 修改启动脚本\n\
cat > etc/init.d/rcS << EOF\n\
#!/bin/sh\n\
mount -t proc proc /proc\n\
mount -t sysfs sysfs /sys\n\
echo ""\n\
echo "========================================"\n\
echo "  Simple Mode (No TrustZone)"\n\
echo "========================================"\n\
echo ""\n\
echo "Note: tee-supplicant skipped in simple mode"\n\
echo "Available TAs:"\n\
ls /lib/optee_armtz/*.ta 2>/dev/null || echo "  (none)"\n\
echo ""\n\
echo "Running test command..."\n\
$TEST_CMD\n\
if [ -n "$CA_FILE" ]; then\n\
    echo "CA_EXIT_CODE=SKIPPED"\n\
fi\n\
echo "=== TEST_COMPLETE ==="\n\
echo ""\n\
echo "========================================"\n\
echo "  Test Complete!"\n\
echo "========================================"\n\
poweroff -f\n\
EOF\n\
chmod +x etc/init.d/rcS\n\
\n\
find . | cpio -H newc -o 2>/dev/null | gzip > /tmp/rootfs_test.cpio.gz\n\
\n\
echo ""\n\
echo "Running QEMU test - Simple Mode (timeout: ${TIMEOUT}s)..."\n\
echo ""\n\
\n\
timeout $TIMEOUT qemu-system-aarch64 \\\n\
    -nographic \\\n\
    -machine virt \\\n\
    -cpu cortex-a57 \\\n\
    -smp 2 \\\n\
    -m 1024 \\\n\
    -kernel /optee/Image \\\n\
    -initrd /tmp/rootfs_test.cpio.gz \\\n\
    -append "console=ttyAMA0 rdinit=/sbin/init" \\\n\
    -no-reboot 2>&1 || true\n\
\n\
rm -rf $WORK_DIR /tmp/rootfs_test.cpio.gz\n\
' > /usr/local/bin/test_ta_simple.sh && chmod +x /usr/local/bin/test_ta_simple.sh

# TA 验证脚本
RUN echo '#!/bin/bash\n\
TA_FILE=$1\n\
if [ -z "$TA_FILE" ] || [ ! -f "$TA_FILE" ]; then\n\
    echo "Usage: validate_ta.sh <ta_file>"\n\
    exit 1\n\
fi\n\
\n\
UUID=$(basename "$TA_FILE" .ta)\n\
\n\
echo "========================================"\n\
echo "OP-TEE TA Validation Report"\n\
echo "========================================"\n\
echo ""\n\
echo "[1] File: $(ls -lh $TA_FILE)"\n\
echo "[2] Type: $(file $TA_FILE)"\n\
echo "[3] UUID: $UUID"\n\
echo ""\n\
echo "[4] Header:"\n\
xxd -l 32 $TA_FILE\n\
echo ""\n\
\n\
# 检查 ELF\n\
ELF_FILE="${TA_FILE%.ta}.stripped.elf"\n\
if [ -f "$ELF_FILE" ]; then\n\
    echo "[5] ELF Sections:"\n\
    aarch64-linux-gnu-objdump -h $ELF_FILE | grep -E "Idx|text|data|rodata"\n\
    echo ""\n\
    echo "[6] Entry Points:"\n\
    aarch64-linux-gnu-nm ${TA_FILE%.ta}.elf 2>/dev/null | grep -E "TA_Create|TA_Open|TA_Invoke|TA_Close|TA_Destroy" || echo "  (stripped)"\n\
fi\n\
echo ""\n\
echo "========================================"\n\
echo "Validation Complete"\n\
echo "========================================"\n\
' > /usr/local/bin/validate_ta.sh && chmod +x /usr/local/bin/validate_ta.sh

# 创建 TA 目录
RUN mkdir -p /optee/ta /workspace

WORKDIR /workspace

# 默认命令
CMD ["/bin/bash"]
